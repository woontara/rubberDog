// Vercel Serverless Function for YouTube Subtitle Extraction
const { YoutubeTranscript } = require('youtube-transcript');
const ytdl = require('ytdl-core');
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

// yt-dlpë¡œ ìë§‰ ëª©ë¡ í™•ì¸ í•¨ìˆ˜
async function getSubtitleListWithYtdlp(videoId) {
  console.log(`ğŸ“‹ yt-dlpë¡œ ìë§‰ ëª©ë¡ í™•ì¸: ${videoId}`);

  try {
    const command = `yt-dlp --list-subs "https://www.youtube.com/watch?v=${videoId}"`;
    console.log(`ğŸ“ yt-dlp ëª…ë ¹ì–´: ${command}`);

    const { stdout, stderr } = await execAsync(command, {
      timeout: 20000,
      encoding: 'utf8'
    });

    if (stderr && stderr.includes('ERROR')) {
      throw new Error(stderr);
    }

    if (stdout) {
      // ìë§‰ ëª©ë¡ì—ì„œ ì–¸ì–´ ì •ë³´ ì¶”ì¶œ
      const languages = [];
      const lines = stdout.split('\n');

      let inSubtitleSection = false;
      for (const line of lines) {
        if (line.includes('Available automatic captions') || line.includes('Available subtitles')) {
          inSubtitleSection = true;
          continue;
        }

        if (inSubtitleSection && line.trim()) {
          // ì–¸ì–´ ì½”ë“œ ì¶”ì¶œ (ì˜ˆ: "ko             Korean")
          const match = line.match(/^(\S+)\s+(.+?)\s+(vtt|srt|ttml)/);
          if (match) {
            const [, langCode, langName] = match;
            if (!languages.includes(`${langCode} (${langName})`)) {
              languages.push(`${langCode} (${langName})`);
            }
          }
        }
      }

      console.log(`âœ… yt-dlp ìë§‰ ëª©ë¡ í™•ì¸ ì„±ê³µ: ${languages.length}ê°œ ì–¸ì–´`);

      return {
        success: true,
        available_languages: languages,
        video_id: videoId,
        raw_output: stdout
      };
    }

    throw new Error('ìë§‰ ëª©ë¡ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');

  } catch (error) {
    console.log(`âŒ yt-dlp ìë§‰ ëª©ë¡ í™•ì¸ ì‹¤íŒ¨: ${error.message}`);

    return {
      success: false,
      error: 'YTDLP_LIST_FAILED',
      message: `yt-dlp ìë§‰ ëª©ë¡ í™•ì¸ ì‹¤íŒ¨: ${error.message}`,
      video_id: videoId
    };
  }
}

// YouTube Data API v3ë¡œ ìë§‰ ì¶”ì¶œí•˜ëŠ” ì‹¤ì œ êµ¬í˜„
async function extractYouTubeSubtitleWithAPI(videoId) {
  console.log(`ğŸ¬ ì‹¤ì œ YouTube APIë¡œ ìë§‰ ì¶”ì¶œ ì‹œë„: ${videoId}`);

  // YouTube Data API í‚¤ë“¤ (í™˜ê²½ë³€ìˆ˜ì—ì„œ ê°€ì ¸ì˜¤ê¸°)
  const apiKeys = [
    process.env.YOUTUBE_API_KEY_PRIMARY,
    process.env.YOUTUBE_API_KEY_BACKUP,
    process.env.YOUTUBE_API_KEY_ADDITIONAL,
    'AIzaSyBQ-VnK7_x8p_Q7n9BQzKnHvQq2RZKZVv8', // ì„ì‹œ í…ŒìŠ¤íŠ¸ìš© í‚¤
    'AIzaSyAO_FJ5W-VK8n2c_K8nQz2hPq2P7KZvqJ8', // ë°±ì—… í‚¤
  ].filter(key => key); // undefined ì œê±°

  console.log(`ğŸ”‘ ì‚¬ìš© ê°€ëŠ¥í•œ API í‚¤ ê°œìˆ˜: ${apiKeys.length}`);
  if (apiKeys.length === 0) {
    console.log(`âŒ API í‚¤ê°€ ì—†ìŠµë‹ˆë‹¤!`);
    return {
      success: false,
      error: 'NO_API_KEYS',
      message: 'YouTube API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.',
      video_id: videoId
    };
  }

  for (let apiKey of apiKeys) {
    try {
      console.log(`ğŸ”‘ API í‚¤ ì‹œë„ ì¤‘...`);

      // 1ë‹¨ê³„: ìë§‰ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
      const captionsListUrl = `https://www.googleapis.com/youtube/v3/captions?part=snippet&videoId=${videoId}&key=${apiKey}`;

      const captionsResponse = await fetch(captionsListUrl);
      const captionsData = await captionsResponse.json();

      if (captionsData.error) {
        console.log(`âŒ API ì˜¤ë¥˜: ${captionsData.error.message}`);
        console.log(`ğŸ“Š ìƒì„¸ ì˜¤ë¥˜ ì •ë³´:`, {
          code: captionsData.error.code,
          status: captionsData.error.status,
          message: captionsData.error.message,
          errors: captionsData.error.errors
        });
        continue;
      }

      if (!captionsData.items || captionsData.items.length === 0) {
        console.log(`â„¹ï¸ ìë§‰ì´ ì—†ëŠ” ì˜ìƒ: ${videoId}`);
        return {
          success: false,
          error: 'NO_CAPTIONS',
          message: 'ì´ ì˜ìƒì—ëŠ” ìë§‰ì´ ì—†ìŠµë‹ˆë‹¤.',
          video_id: videoId
        };
      }

      // í•œêµ­ì–´ ìë§‰ ìš°ì„  ì°¾ê¸°
      let targetCaption = captionsData.items.find(item =>
        item.snippet.language === 'ko' || item.snippet.language === 'ko-KR'
      );

      // í•œêµ­ì–´ê°€ ì—†ìœ¼ë©´ ì˜ì–´ ì°¾ê¸°
      if (!targetCaption) {
        targetCaption = captionsData.items.find(item =>
          item.snippet.language === 'en' || item.snippet.language === 'en-US'
        );
      }

      // ê·¸ê²ƒë„ ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ ìë§‰ ì‚¬ìš©
      if (!targetCaption) {
        targetCaption = captionsData.items[0];
      }

      console.log(`ğŸ“ ìë§‰ ë°œê²¬: ${targetCaption.snippet.language} - ${targetCaption.snippet.name}`);

      // 2ë‹¨ê³„: ì‹¤ì œ ìë§‰ ë‹¤ìš´ë¡œë“œ ì‹œë„
      // ê³µì‹ captions.download APIë¡œ ë‹¤ì–‘í•œ í˜•ì‹ ì‹œë„
      const formats = ['srt', 'vtt', 'ttml'];

      for (let format of formats) {
        try {
          const downloadUrl = `https://www.googleapis.com/youtube/v3/captions/${targetCaption.id}?key=${apiKey}&tfmt=${format}`;
          const downloadResponse = await fetch(downloadUrl);

          if (downloadResponse.ok) {
            const subtitleContent = await downloadResponse.text();
            console.log(`âœ… ê³µì‹ APIë¡œ ìë§‰ ë‹¤ìš´ë¡œë“œ ì„±ê³µ: ${videoId} (${format})`);

            // SRT í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ì¼ê´€ëœ í˜•ì‹ ì œê³µ
            let formattedSubtitle = subtitleContent;
            if (format === 'vtt') {
              // VTTë¥¼ SRT í˜•ì‹ìœ¼ë¡œ ê°„ë‹¨ ë³€í™˜
              formattedSubtitle = subtitleContent
                .replace(/WEBVTT\n\n/, '')
                .replace(/(\d{2}:\d{2}:\d{2}\.\d{3}) --> (\d{2}:\d{2}:\d{2}\.\d{3})/g, '$1,000 --> $2,000');
            }

            return {
              success: true,
              subtitle: formattedSubtitle,
              language: targetCaption.snippet.name || targetCaption.snippet.language,
              language_code: targetCaption.snippet.language,
              is_generated: targetCaption.snippet.trackKind === 'ASR',
              video_id: videoId,
              format: format,
              note: `YouTube Data API v3 ê³µì‹ captions.downloadë¡œ ì¶”ì¶œ (${format} í˜•ì‹)`
            };
          }
        } catch (downloadError) {
          console.log(`âš ï¸ ${format} í˜•ì‹ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨: ${downloadError.message}`);
          continue;
        }
      }

      // ê³µì‹ API ì‹¤íŒ¨ ì‹œ youtube-transcript ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ ë‹¤ì–‘í•œ ë°©ì‹ ì‹œë„
      const languages = [
        targetCaption.snippet.language,
        'ko', 'en', 'auto'
      ];

      for (let lang of languages) {
        try {
          console.log(`ğŸŒ youtube-transcriptë¡œ ${lang} ì–¸ì–´ ì‹œë„ ì¤‘...`);

          const options = lang === 'auto' ? {} : { lang };
          const transcript = await YoutubeTranscript.fetchTranscript(videoId, options);

          if (transcript && transcript.length > 0) {
            let subtitleText = '';
            transcript.forEach(entry => {
              const startTime = Math.floor(entry.offset / 1000);
              const minutes = Math.floor(startTime / 60);
              const seconds = startTime % 60;
              const timestamp = `[${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}]`;

              if (entry.text && entry.text.trim()) {
                subtitleText += `${timestamp} ${entry.text.trim()}\n`;
              }
            });

            console.log(`âœ… youtube-transcriptë¡œ ìë§‰ ì¶”ì¶œ ì„±ê³µ: ${videoId} (${lang})`);
            return {
              success: true,
              subtitle: subtitleText.trim(),
              language: targetCaption.snippet.name || targetCaption.snippet.language,
              language_code: lang,
              is_generated: targetCaption.snippet.trackKind === 'ASR',
              video_id: videoId,
              method: 'youtube-transcript',
              note: `youtube-transcript ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ ìë§‰ ì¶”ì¶œ ì„±ê³µ (${lang})`
            };
          }
        } catch (transcriptError) {
          console.log(`âš ï¸ youtube-transcript ${lang} ì‹¤íŒ¨: ${transcriptError.message}`);

          // CAPTCHA ìš”êµ¬ ê°ì§€
          if (transcriptError.message.includes('captcha') || transcriptError.message.includes('too many requests')) {
            console.log(`ğŸš¨ CAPTCHA/ìš”ì²­ ì œí•œ ê°ì§€: ${transcriptError.message}`);
            return {
              success: false,
              error: 'CAPTCHA_REQUIRED',
              message: 'YouTubeì—ì„œ CAPTCHAë¥¼ ìš”êµ¬í•©ë‹ˆë‹¤. Vercel ì„œë²„ì˜ IPê°€ ì°¨ë‹¨ëœ ê²ƒ ê°™ìŠµë‹ˆë‹¤.',
              video_id: videoId,
              detailed_error: transcriptError.message
            };
          }
          continue;
        }
      }

      // ì–¸ì–´ ì§€ì • ì—†ì´ ë§ˆì§€ë§‰ ì‹œë„
      try {
        console.log(`ğŸ”„ youtube-transcript ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ ë§ˆì§€ë§‰ ì‹œë„...`);
        const transcript = await YoutubeTranscript.fetchTranscript(videoId);

        if (transcript && transcript.length > 0) {
          let subtitleText = '';
          transcript.forEach(entry => {
            const startTime = Math.floor(entry.offset / 1000);
            const minutes = Math.floor(startTime / 60);
            const seconds = startTime % 60;
            const timestamp = `[${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}]`;

            if (entry.text && entry.text.trim()) {
              subtitleText += `${timestamp} ${entry.text.trim()}\n`;
            }
          });

          console.log(`âœ… youtube-transcript ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ ìë§‰ ì¶”ì¶œ ì„±ê³µ: ${videoId}`);
          return {
            success: true,
            subtitle: subtitleText.trim(),
            language: 'Auto-detected',
            language_code: 'auto',
            is_generated: true,
            video_id: videoId,
            method: 'youtube-transcript-default',
            note: 'youtube-transcript ë¼ì´ë¸ŒëŸ¬ë¦¬ ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ ìë§‰ ì¶”ì¶œ ì„±ê³µ'
          };
        }
      } catch (transcriptError) {
        console.log(`âš ï¸ youtube-transcript ê¸°ë³¸ ì„¤ì • ì‹¤íŒ¨: ${transcriptError.message}`);
      }

      // 4ë‹¨ê³„: yt-dlp ìë§‰ ëª©ë¡ í™•ì¸
      try {
        console.log(`ğŸ”„ 4ë‹¨ê³„: yt-dlpë¡œ ìë§‰ ëª©ë¡ í™•ì¸...`);

        const ytdlpResult = await getSubtitleListWithYtdlp(videoId);
        if (ytdlpResult.success && ytdlpResult.available_languages.length > 0) {
          console.log(`ğŸ“‹ yt-dlp ìë§‰ ëª©ë¡ í™•ì¸ ì„±ê³µ: ${ytdlpResult.available_languages.length}ê°œ ì–¸ì–´`);

          return {
            success: true,
            subtitle: `[ìë§‰ ì •ë³´]\n\nâœ… ì´ ì˜ìƒì—ëŠ” ${ytdlpResult.available_languages.length}ê°œ ì–¸ì–´ì˜ ìë§‰ì´ ìˆìŠµë‹ˆë‹¤!\n\nğŸ“‹ ì‚¬ìš© ê°€ëŠ¥í•œ ì–¸ì–´:\n${ytdlpResult.available_languages.map(lang => `â€¢ ${lang}`).join('\n')}\n\nâš ï¸ í˜„ì¬ YouTubeì˜ ë³´ì•ˆ ì •ì±…ìœ¼ë¡œ ì¸í•´ ìë§‰ ë‚´ìš©ì„ ì§ì ‘ ì¶”ì¶œí•  ìˆ˜ ì—†ì§€ë§Œ,\nìë§‰ì´ ì¡´ì¬í•¨ì„ í™•ì¸í–ˆìŠµë‹ˆë‹¤.\n\nğŸ¯ í•´ê²°ì±…:\n1. YouTubeì—ì„œ ì§ì ‘ ìë§‰ í™•ì¸\n2. ë¸Œë¼ìš°ì € í™•ì¥ í”„ë¡œê·¸ë¨ ì‚¬ìš©\n3. ì¶”í›„ ê¸°ìˆ ì  í•´ê²°ì±… ì ìš©\n\nì˜ìƒ ID: ${videoId}\ní™•ì¸ ì‹œê°„: ${new Date().toLocaleString('ko-KR')}`,
            language: 'Multiple',
            language_code: 'multi',
            is_generated: true,
            video_id: videoId,
            method: 'yt-dlp-list',
            note: 'yt-dlpë¡œ ìë§‰ ëª©ë¡ í™•ì¸ ì„±ê³µ',
            ytdlp_result: ytdlpResult
          };
        }
      } catch (ytdlpError) {
        console.log(`âš ï¸ yt-dlp ìë§‰ ëª©ë¡ í™•ì¸ ì‹¤íŒ¨: ${ytdlpError.message}`);
      }

      // ìë§‰ ëª©ë¡ì€ ìˆì§€ë§Œ ë‹¤ìš´ë¡œë“œí•  ìˆ˜ ì—†ëŠ” ê²½ìš°
      return {
        success: false,
        error: 'DOWNLOAD_FAILED',
        message: 'ìë§‰ì´ ì¡´ì¬í•˜ì§€ë§Œ ë‹¤ìš´ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ê¶Œí•œ ì œí•œ)',
        available_languages: captionsData.items.map(item => ({
          language: item.snippet.language,
          name: item.snippet.name,
          kind: item.snippet.trackKind
        })),
        video_id: videoId
      };

    } catch (error) {
      console.log(`âŒ API í‚¤ ì‹¤íŒ¨: ${error.message}`);
      continue;
    }
  }

  // ëª¨ë“  API í‚¤ê°€ ì‹¤íŒ¨í•œ ê²½ìš°
  return {
    success: false,
    error: 'API_FAILED',
    message: 'ëª¨ë“  API í‚¤ê°€ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. í• ë‹¹ëŸ‰ ì´ˆê³¼ ë˜ëŠ” í‚¤ ë¬¸ì œì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
    video_id: videoId
  };
}

// ytdl-coreë¥¼ ì‚¬ìš©í•œ ìë§‰ ì¶”ì¶œ ì‹œë„
async function extractYouTubeSubtitleWithYtdl(videoId) {
  console.log(`ğŸ”„ ytdl-coreë¡œ ìë§‰ ì¶”ì¶œ ì‹œë„: ${videoId}`);

  try {
    const url = `https://www.youtube.com/watch?v=${videoId}`;

    // ytdl-coreë¡œ ì˜ìƒ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    const info = await ytdl.getInfo(url);

    // ìë§‰ íŠ¸ë™ ì°¾ê¸°
    const playerResponse = info.player_response;
    const captions = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;

    if (!captions || captions.length === 0) {
      console.log(`â„¹ï¸ ytdl-core: ìë§‰ì´ ì—†ëŠ” ì˜ìƒ: ${videoId}`);
      return {
        success: false,
        error: 'NO_CAPTIONS_YTDL',
        message: 'ytdl-core: ì´ ì˜ìƒì—ëŠ” ìë§‰ì´ ì—†ìŠµë‹ˆë‹¤.',
        video_id: videoId
      };
    }

    // ì–¸ì–´ ìš°ì„ ìˆœìœ„: í•œêµ­ì–´ â†’ ì˜ì–´ â†’ ì²« ë²ˆì§¸ ìë§‰
    const preferredLanguages = ['ko', 'ko-KR', 'en', 'en-US'];
    let targetCaption = null;

    for (const lang of preferredLanguages) {
      targetCaption = captions.find(caption =>
        caption.languageCode === lang || caption.languageCode.startsWith(lang)
      );
      if (targetCaption) break;
    }

    if (!targetCaption) {
      targetCaption = captions[0]; // ì²« ë²ˆì§¸ ìë§‰ ì‚¬ìš©
    }

    console.log(`ğŸ“ ytdl-core ìë§‰ ë°œê²¬: ${targetCaption.languageCode} - ${targetCaption.name?.simpleText || 'Unknown'}`);

    // ìë§‰ URLì—ì„œ ìë§‰ ë‹¤ìš´ë¡œë“œ
    const subtitleUrl = targetCaption.baseUrl;
    const response = await fetch(subtitleUrl);

    if (!response.ok) {
      throw new Error(`ìë§‰ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨: ${response.status}`);
    }

    const subtitleXml = await response.text();

    // ê°„ë‹¨í•œ XML â†’ SRT ë³€í™˜
    const srtContent = convertXmlToSrt(subtitleXml);

    if (srtContent && srtContent.trim().length > 0) {
      console.log(`âœ… ytdl-coreë¡œ ìë§‰ ì¶”ì¶œ ì„±ê³µ: ${videoId}`);
      return {
        success: true,
        subtitle: srtContent,
        language: targetCaption.name?.simpleText || targetCaption.languageCode,
        language_code: targetCaption.languageCode,
        is_generated: targetCaption.kind === 'asr',
        video_id: videoId,
        method: 'ytdl-core',
        note: `ytdl-coreë¡œ ìë§‰ ì¶”ì¶œ ì„±ê³µ (${targetCaption.languageCode})`
      };
    }

  } catch (error) {
    console.log(`âŒ ytdl-core ì˜¤ë¥˜: ${error.message}`);
    return {
      success: false,
      error: 'YTDL_ERROR',
      message: `ytdl-core ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: ${error.message}`,
      video_id: videoId,
      detailed_error: error.message
    };
  }

  return {
    success: false,
    error: 'YTDL_EXTRACTION_FAILED',
    message: 'ytdl-coreë¡œ ìë§‰ ì¶”ì¶œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.',
    video_id: videoId
  };
}

// XML ìë§‰ì„ SRT í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” ê°„ë‹¨í•œ í•¨ìˆ˜
function convertXmlToSrt(xmlContent) {
  try {
    // XML íŒŒì‹± ë° SRT ë³€í™˜ (ê°„ë‹¨í•œ êµ¬í˜„)
    const lines = xmlContent.split('\n');
    let srtContent = '';
    let counter = 1;

    for (const line of lines) {
      const match = line.match(/<text start="([^"]*)"[^>]*dur="([^"]*)"[^>]*>([^<]*)<\/text>/);
      if (match) {
        const start = parseFloat(match[1]);
        const duration = parseFloat(match[2]);
        const text = match[3].replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>');

        const startTime = formatTime(start);
        const endTime = formatTime(start + duration);

        srtContent += `${counter}\n${startTime} --> ${endTime}\n${text}\n\n`;
        counter++;
      }
    }

    return srtContent.trim();
  } catch (error) {
    console.log(`âŒ XML â†’ SRT ë³€í™˜ ì˜¤ë¥˜: ${error.message}`);
    return '';
  }
}

// ì‹œê°„ì„ SRT í˜•ì‹ìœ¼ë¡œ ë³€í™˜ (00:00:00,000)
function formatTime(seconds) {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const milliseconds = Math.floor((seconds % 1) * 1000);

  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${milliseconds.toString().padStart(3, '0')}`;
}

// ê¸°ì¡´ youtube-transcriptë§Œ ì‚¬ìš©í•˜ëŠ” ë°±ì—… ë°©ë²• (ë” ê°•í™”ëœ ë²„ì „)
async function extractYouTubeSubtitleFallback(videoId) {
  console.log(`ğŸ”„ ë°±ì—… ë°©ë²•ìœ¼ë¡œ ìë§‰ ì¶”ì¶œ ì‹œë„: ${videoId}`);

  try {
    // ì£¼ìš” ì–¸ì–´ ì˜µì…˜ë§Œ ì‹œë„ (ì„±ëŠ¥ í–¥ìƒ)
    const languageOptions = [
      { lang: 'ko' },
      { lang: 'ko-KR' },
      { lang: 'en' },
      { lang: 'en-US' },
      { lang: 'ja' },
      {} // ì–¸ì–´ ì§€ì • ì—†ìŒ (ê°€ì¥ ì•ˆì •ì )
    ];

    for (let options of languageOptions) {
      try {
        const langCode = options.lang || 'auto';
        console.log(`ğŸŒ ë°±ì—…: ${langCode} ì˜µì…˜ìœ¼ë¡œ ì‹œë„ ì¤‘...`);

        const transcript = await YoutubeTranscript.fetchTranscript(videoId, options);

        if (transcript && transcript.length > 0) {
          let subtitleText = '';
          transcript.forEach(entry => {
            const startTime = Math.floor(entry.offset / 1000);
            const minutes = Math.floor(startTime / 60);
            const seconds = startTime % 60;
            const timestamp = `[${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}]`;

            if (entry.text && entry.text.trim()) {
              subtitleText += `${timestamp} ${entry.text.trim()}\n`;
            }
          });

          console.log(`âœ… ë°±ì—… ë°©ë²•ìœ¼ë¡œ ìë§‰ ì¶”ì¶œ ì„±ê³µ: ${videoId} (${langCode})`);
          return {
            success: true,
            subtitle: subtitleText.trim(),
            language: langCode === 'ko' || langCode === 'ko-KR' ? 'Korean' :
                      langCode === 'en' || langCode === 'en-US' || langCode === 'en-GB' ? 'English' :
                      langCode === 'auto' ? 'Auto-detected' : langCode,
            language_code: langCode,
            is_generated: langCode === 'auto',
            video_id: videoId,
            method: 'youtube-transcript-fallback',
            note: `youtube-transcript ë°±ì—… ë°©ë²•ìœ¼ë¡œ ìë§‰ ì¶”ì¶œ ì„±ê³µ (${langCode})`
          };
        }
      } catch (langError) {
        console.log(`âš ï¸ ë°±ì—…: ${options.lang || 'default'} ì‹¤íŒ¨: ${langError.message}`);

        // CAPTCHA ìš”êµ¬ ê°ì§€
        if (langError.message.includes('captcha') || langError.message.includes('too many requests')) {
          console.log(`ğŸš¨ ë°±ì—…ì—ì„œë„ CAPTCHA/ìš”ì²­ ì œí•œ ê°ì§€: ${langError.message}`);
          return {
            success: false,
            error: 'CAPTCHA_REQUIRED',
            message: 'YouTubeì—ì„œ CAPTCHAë¥¼ ìš”êµ¬í•©ë‹ˆë‹¤. Vercel ì„œë²„ì˜ IPê°€ ì°¨ë‹¨ëœ ê²ƒ ê°™ìŠµë‹ˆë‹¤.',
            video_id: videoId,
            detailed_error: langError.message,
            method: 'youtube-transcript-fallback'
          };
        }
        continue;
      }
    }

  } catch (error) {
    console.error(`âŒ ë°±ì—… ë°©ë²• ì‹¤íŒ¨: ${videoId}`, error.message);
  }

  return {
    success: false,
    error: 'EXTRACTION_FAILED',
    message: 'ëª¨ë“  ë°©ë²•ìœ¼ë¡œ ìë§‰ ì¶”ì¶œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.',
    video_id: videoId
  };
}

// ë©”ì¸ ìë§‰ ì¶”ì¶œ í•¨ìˆ˜ (ë‹¨ìˆœí•˜ê³  ì•ˆì •ì ì¸ ë°©ë²•ìœ¼ë¡œ ë³€ê²½)
async function extractYouTubeSubtitle(videoId) {
  console.log(`ğŸ¬ ìë§‰ ì¶”ì¶œ ì‹œì‘: ${videoId}`);

  // ë‹¨ìˆœí•˜ê³  ì•ˆì •ì ì¸ youtube-transcript ë°©ë²•ë§Œ ì‚¬ìš©
  const result = await extractYouTubeSubtitleFallback(videoId);
  if (result.success) {
    return result;
  }

  // ì‹¤íŒ¨í•œ ê²½ìš°
  console.log(`âŒ ìë§‰ ì¶”ì¶œ ì‹¤íŒ¨: ${videoId}`);
  return {
    success: false,
    error: 'EXTRACTION_FAILED',
    subtitle: `[ìë§‰ ì¶”ì¶œ ì‹¤íŒ¨]\n\ní˜„ì¬ ì´ ì˜ìƒì˜ ìë§‰ì„ ì¶”ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\nê°€ëŠ¥í•œ ì›ì¸:\nâ€¢ ì˜ìƒì— ìë§‰ì´ ì—†ìŒ\nâ€¢ ë¹„ê³µê°œ ë˜ëŠ” ì œí•œëœ ì˜ìƒ\nâ€¢ YouTube ë³´ì•ˆ ì •ì±…ìœ¼ë¡œ ì¸í•œ ì ‘ê·¼ ì œí•œ\n\nğŸ¯ í•´ê²° ë°©ë²•:\n1. YouTubeì—ì„œ ì§ì ‘ ìë§‰ í™•ì¸\n2. ê³µê°œ ì˜ìƒì¸ì§€ í™•ì¸\n3. ë‹¤ë¥¸ ì˜ìƒìœ¼ë¡œ ì‹œë„\n\nì˜ìƒ ID: ${videoId}\nì²˜ë¦¬ ì‹œê°„: ${new Date().toLocaleString('ko-KR')}`,
    language: 'Korean',
    language_code: 'ko',
    is_generated: true,
    video_id: videoId,
    note: 'ë‹¨ìˆœí™”ëœ ìë§‰ ì¶”ì¶œ ë°©ë²•ìœ¼ë¡œ ì‹¤íŒ¨',
    detailed_error: result.error || 'Unknown error'
  };
}

// Vercel ì„œë²„ë¦¬ìŠ¤ í•¨ìˆ˜ (ì•ˆì •ì ì¸ ë‹¨ìˆœ ë°©ë²•ìœ¼ë¡œ ìˆ˜ì •)
module.exports = async (req, res) => {
  // CORS í—¤ë” ì„¤ì •
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  if (req.method !== 'POST') {
    res.status(405).json({ error: 'Method not allowed' });
    return;
  }

  try {
    const { videoId, title } = req.body;
    console.log('ğŸ¬ Vercel APIë¡œ ìë§‰ ì¶”ì¶œ ìš”ì²­:', { videoId, title });

    if (!videoId) {
      res.status(400).json({ error: 'videoId is required' });
      return;
    }

    console.log(`ğŸ¬ ì§ì ‘ ìë§‰ ì¶”ì¶œ ì‹œì‘: ${videoId}`);

    // ì§ì ‘ ì•ˆì •ì ì¸ ë°©ë²•ë§Œ ì‚¬ìš©
    const result = await extractYouTubeSubtitleFallback(videoId);
    console.log(`âœ… ìë§‰ ì¶”ì¶œ ì™„ë£Œ: ${videoId}`, result.success ? 'ì„±ê³µ' : 'ì‹¤íŒ¨');
    res.status(200).json(result);

  } catch (error) {
    console.error('ìë§‰ ì¶”ì¶œ API ì˜¤ë¥˜:', error);
    res.status(500).json({
      error: error.message,
      stack: error.stack
    });
  }
};